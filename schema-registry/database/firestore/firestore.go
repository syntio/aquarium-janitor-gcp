// Copyright 2020 Syntio Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package firestore

import (
	"context"
	"log"
	"os"

	"cloud.google.com/go/firestore"
	firebase "firebase.google.com/go"
	"github.com/syntio/schema-registry/configuration"
	"github.com/syntio/schema-registry/model"
	"github.com/syntio/schema-registry/model/dto"
	"github.com/syntio/schema-registry/util"
	"google.golang.org/api/iterator"
	"google.golang.org/api/option"
)

//
//	Firestore implementation for database.DBExecutor interface.
//
type FirestoreDB struct {
	Collection string
}

var client *firestore.Client

func init() {
	ctx := context.Background()
	credFilename := os.Getenv("FIREBASE_CREDENTIALS_NAME")
	bucket := os.Getenv("BUCKET_NAME")
	json := configuration.ReadFromBucket(bucket, credFilename)
	option := option.WithCredentialsJSON(json)
	projectId := os.Getenv("PROJECT_ID")
	conf := &firebase.Config{ProjectID:projectId}
	app, err := firebase.NewApp(ctx, conf, option)
	if err != nil {
		log.Fatalf("Firestore setup error. Server can't start properly.\nError: %s", err)
	}

	handler, err := app.Firestore(ctx)
	if err != nil {
		log.Fatalf("Firestore client initialization failed. Server can't start properly.\nError: %s", err)
	}

	client = handler
}

// GetSchemaByIdAndVersion retrieves a schema by its id and version. Method returns a boolean flag which defines
// if the wanted schema exists. If the schema is found, representing SchemaInfo is retrieved.
func (db *FirestoreDB) GetSchemaByIdAndVersion(ctx context.Context, id string, version int32) (*model.Schema, bool) {
	document, err := client.Collection(db.Collection).Doc(id).Get(ctx)
	if err != nil {

		return nil, false
	}
	var result *model.Schema
	if err = document.DataTo(&result); err != nil {

		return nil, false
	}

	for i, v := range result.SchemaDetails {
		if v.Version == version {
			new_details := result.SchemaDetails[i : i+1]
			result.SchemaDetails = new_details
			return result, true
		}
	}

	return nil, false
}

// GetSchemaBversions returns a list of SchemaDetails from the database.
// The input arguments are the request contex and the document/row ID.
// The return value is a list of model.SchemaDetails and an error in case of a fault or failure.
func (db *FirestoreDB) GetSchemaVersions(ctx context.Context, id string) (*[]*model.SchemaDetails, error) {
	document, err := client.Collection(db.Collection).Doc(id).Get(ctx)
	if err != nil {
		return nil, err
	}
	var result *model.Schema
	if err = document.DataTo(&result); err != nil {
		return nil, err
	}
	return &result.SchemaDetails, nil
}

//UpdateSchemaById updates the schema Specification e.g. creates a new entry of SchemaDetails.
// The input arguments are the request context, followed by the ID string of the document/row ID,
// specification in []byte form and a flag indicating if Schema was manully updated or dynamically evolved.
// The output is an model.InsertInfo structure, a flag indicating if new version of schema was added and an error.
func (db *FirestoreDB) UpdateSchemaById(ctx context.Context, id string,
	schema []byte, autogenerated bool) (*model.InsertInfo, bool, error) {
	document, err := client.Collection(db.Collection).Doc(id).Get(ctx)
	if err != nil {
		return nil, false, err
	}
	var result *model.Schema
	if err = document.DataTo(&result); err != nil {
		return nil, false, err
	}

	hash := util.CalculateSchemaHash(schema)

	if exists, info := db.existsByHash(hash, result); exists {
		log.Printf("Schema %v with version %d already exists ", info.Id, info.Version)
		return info, false, nil
	}

	newVer := int32(len(result.SchemaDetails) + 1)

	d := &model.SchemaDetails{
		Version:       newVer,
		SchemaHash:    hash,
		Specification: util.SchemaBase64Encode(schema),
	}
	details := result.SchemaDetails
	details = append(details, d)
	result.SchemaDetails = details
	info := &model.InsertInfo{
		Id:      result.Id,
		Version: newVer,
	}

	if _, err := client.Collection(db.Collection).Doc(id).Set(ctx, result); err != nil {
		log.Println("Could not update new schema")
		return nil, false, err
	}

	return info, true, nil

}

// CreateSchema persists a new Schema structure into the document or relational database.
// Input arguemtns are request context, and a DTO describing the basic new schema parameters.
// The output is an model.InsertInfo structure, a flag indicating if new version of schema was added and an error.
func (db *FirestoreDB) CreateSchema(ctx context.Context, dto *dto.SchemaDTO) (*model.InsertInfo, bool, error) {
	byteSchema := []byte(dto.Specification)
	hash := util.CalculateSchemaHash(byteSchema)

	it := client.Collection(db.Collection).Documents(ctx)
	for sh, err := it.Next(); err != iterator.Done; sh, err = it.Next() {
		if err != nil {
			log.Println("Could not read existing data")
			return nil, false, err
		}
		var schema *model.Schema
		err = sh.DataTo(&schema)
		if err != nil {
			return nil, false, err
		}
		if exists, info := db.existsByHash(hash, schema); exists {
			return info, false, err
		}
	}
	version := int32(1)
	doc := client.Collection(db.Collection).NewDoc()

	sc := util.DtoToSchema(dto, doc.ID, hash, byteSchema, version)
	if _, err := doc.Set(ctx, sc); err != nil {
		log.Println("Could not create new schema")
		return nil, false, err
	}
	info := &model.InsertInfo{
		Id:      doc.ID,
		Version: version,
	}
	return info, true, nil
}

// existsByHash is a helper function that checks if there is a corresponding hash in a schema.
// the input arguments are a sha-256 hash of the schema specification and a model.Schema struct.
// the output is a flag indicating if the schema exists, and were the flag true the corresponding model.InsertInfo
// struct.
func (db *FirestoreDB) existsByHash(hash string, schema *model.Schema) (bool, *model.InsertInfo) {
	var info *model.InsertInfo
	for _, sd := range schema.SchemaDetails {
		if sd.SchemaHash == hash {
			info = &model.InsertInfo{
				Id:      schema.Id,
				Version: sd.Version,
			}
			return true, info
		}
	}
	return false, nil
}

// DeleteById deletes a schema from the document database
// Input arguemnts are request contex and a string ID of the document.
// An error is returned if the id were wrong or if arbitrary connection issues were at hand.
func (db *FirestoreDB) DeleteById(ctx context.Context, id string) error {
	_, err := client.Collection(db.Collection).Doc(id).Delete(ctx)
	return err
}
