package business_logic

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"

	"github.com/syntio/schema-registry/configuration"
	"github.com/syntio/schema-registry/database"
	"github.com/syntio/schema-registry/database/firestore"
	"github.com/syntio/schema-registry/model/dto"
	"github.com/syntio/schema-registry/util"
)

var databaseExecutor database.DBExecutor

func init() {
	cfg := configuration.RetrieveConfig()

	databaseExecutor = &firestore.FirestoreDB{
		Collection: cfg.FirebaseCollectionName,
	}
}

// GetSchema invokes the database executor retrieving the latest schema.
//
// The input arguments are the request context, a schemaId and a version of a schema.
//
// The output of this function is a marhsaled schema and a boolean which indicates if schema was found.
func GetSchema(ctx context.Context, schemaId string, version int32) ([]byte, bool) {
	schemaInfo, found := databaseExecutor.GetSchemaByIdAndVersion(ctx, schemaId, version)
	jsonResponse, err := json.Marshal(schemaInfo)
	if err != nil {
		return nil, found
	}

	return jsonResponse, found
}

// CreateSchema invokes the database executor to create a new schema document.
//
// The input arguments are the request context, and a data transfer object,
// in which are all required assets  for a new schema
//
// The output of this function is a marshaled schema and an error.
func CreateSchema(ctx context.Context, schemaInfoDTO dto.SchemaDTO) ([]byte, error) {
	insertInfo, added, err := databaseExecutor.CreateSchema(ctx, &schemaInfoDTO)
	var message string

	if err != nil {
		return nil, err
	}

	if added {
		message = "New Schema added"
	} else {
		message = "Shcema already exists in the registry"
	}

	response := util.MapToResponse(insertInfo, message)

	if jsonResponse, err := json.Marshal(response); err != nil {
		return nil, err
	} else {
		return jsonResponse, nil
	}

}

// Evolve tries to construct a schema from a given message. JSON and CSV are supported for now
//
// The input argument is the evolution data transfer object, which hold the format and data that
// needs to be evolved.
//
// The output of this function is a new generated schema []byte, a boolean that indicates succesful
// creation and an error.
func Evolve(evolution dto.EvolutionDTO) ([]byte, bool, error) {
	results, err := util.CallFunction(fmt.Sprintf("schema_creation.%sSchemaDynamicCreation",
		strings.ToUpper(evolution.Format)),
		[]byte(evolution.Data))
	if err != nil {
		log.Println("Could not invoke Creation Method")
		return nil, false, err
	}

	generatedSchema := results[3].([]byte)
	isGenerated := results[4].(bool)
	e := results[5]
	if e != nil {
		err = results[5].(error)
	}
	if err != nil {
		return nil, false, err
	}
	return generatedSchema, isGenerated, nil
}

// UpdateSchema invokes the databaseExecutor to update an existing schema document in the collection.
//
// The input argument is the request context, a schemaId and a specification data transfer object
// which is actually a wrapper structure, wrapping a new schema definition.
//
// The output of this function is a marshaled insert info object and an error.
func UpdateSchema(ctx context.Context,
	schemaId string,
	specification *dto.SpectificationDTO, autogenerated bool) ([]byte, error) {
	insertInfo, updated, err := databaseExecutor.
		UpdateSchemaById(ctx, schemaId, []byte(specification.Specification), false)
	var message string

	if err != nil {
		return nil, err
	}
	if updated {
		message = "Successfully updated schema"
	} else {
		message = fmt.Sprintf("Schema already exists on id: %s ", insertInfo.Id)
	}

	response := util.MapToResponse(insertInfo, message)

	if jsonResponse, err := json.Marshal(response); err != nil {
		return nil, err
	} else {
		return jsonResponse, nil
	}

}

// ListSchemas invokes the databaseExecutor to retireve all schema versions of a specific schema document.
//
// The input arguments are the request context and schemaId.
//
// The output of this function is a marshaled insert info object and an error.
func ListSchemas(ctx context.Context, schemaId string) ([]byte, error) {
	res, err := databaseExecutor.GetSchemaVersions(ctx, schemaId)
	if err != nil {
		return nil, err
	}
	return json.Marshal(res)

}
