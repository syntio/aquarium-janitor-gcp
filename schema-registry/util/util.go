// Copyright 2020 Syntio Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package util holds general helping functions needed for the Schema Registry system.
package util

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"errors"
	"log"
	"path/filepath"
	"reflect"
	"strconv"
	"time"

	"github.com/syntio/schema-registry/schema_creation"

	"github.com/syntio/schema-registry/model"
	"github.com/syntio/schema-registry/model/dto"
)

var b64coder *base64.Encoding

var fnStorage = map[string]interface{}{
	"schema_creation.CSVSchemaDynamicCreation":  schema_creation.CSVSchemaDynamicCreation,
	"schema_creation.JSONSchemaDynamicCreation": schema_creation.JSONSchemaDynamicCreation,
}

// init function is executed before anything else in the file.
// initiates the base64 encoder.
func init() {
	b64coder = base64.StdEncoding
}

// Creates a string representing a filepath using the given elements
func RelativePath(elements ...string) string {
	relativePath := filepath.Join(elements...)
	return relativePath
}

// Calculates schema hash using SHA1 algorithm
func CalculateSchemaHash(schema []byte) string {
	hasher := sha256.New()
	_, err := hasher.Write(schema)
	if err != nil {
		log.Fatal(err)
	}
	resultHash := hasher.Sum(nil)
	hexHashString := hex.EncodeToString(resultHash)
	return hexHashString
}

// Performs a Base64 encoding of the string
func SchemaBase64Encode(schema []byte) string {
	encodedString := b64coder.EncodeToString(schema)
	return encodedString
}

// Performs a Base64 decoding of the string
func SchemaBase64Decode(schemaBase64 string) ([]byte, error) {
	decodedBytes, err := b64coder.DecodeString(schemaBase64)
	return decodedBytes, err
}

// Converts a string to int64
func StringToInt64(number string) (int64, error) {
	result, err := strconv.ParseInt(number, 10, 64)
	return result, err
}

// Converts a string to int32
func StringToInt32(number string) (int32, error) {
	result, err := strconv.ParseInt(number, 10, 32)
	return int32(result), err
}

// Converts a integer to string
func IntToString(number int64) string {
	return strconv.FormatInt(number, 10)
}

func MapToResponse(insertInfo *model.InsertInfo, message string) *dto.InsertInfoDTO {
	response := &dto.InsertInfoDTO{
		Id:      insertInfo.Id,
		Version: insertInfo.Version,
		Message: message,
	}
	return response
}

// Uses reflection to call a function by its given name along with parameters.
// The output of this is a slice of interfaces representing the outputs of the function, along with an error
// were the function invoked in a wrong way or non existant.
func CallFunction(name string, params ...interface{}) ([]interface{}, error) {
	n := fnStorage[name]
	fn := reflect.ValueOf(n)
	if len(params) != fn.Type().NumIn() {
		return nil, errors.New("The number of params is out of index.")
	}

	in := make([]reflect.Value, len(params))

	for k, param := range params {
		in[k] = reflect.ValueOf(param)
	}

	res := fn.Call(in)

	result := make([]interface{}, len(res))
	for i := 0; i < len(res); i++ {
		result = append(result, res[i].Interface())
	}

	return result, nil
}

// Mapper util for converting a dto with additional data, into a model.Schema
func DtoToSchema(dto *dto.SchemaDTO, id string, hash string, specification []byte, version int32) *model.Schema {
	schema := &model.Schema{
		Id:            id,
		Autogenerated: false,
		CreationDate:  time.Now(),
		Description:   dto.Description,
		Name:          dto.Name,
		SchemaType:    dto.SchemaType,
	}
	details := make([]*model.SchemaDetails, 0)
	details = append(details, &model.SchemaDetails{
		Version:       version,
		SchemaHash:    hash,
		Specification: SchemaBase64Encode(specification),
	})
	schema.SchemaDetails = details
	return schema
}
